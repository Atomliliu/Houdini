//
// VEX Code Generated by Houdini 18.5.696
// Date: Wed Oct 27 23:09:55 2021
// File: C:/Atom/Houdini/SH/SH_v025_LL
// Node: /obj/sphere_example/sample_surrounding_occlusion
//

#ifndef VOP_OP
#define VOP_OP
#endif
#ifndef VOP_SOP
#define VOP_SOP
#endif

#pragma opname sample_surrounding_occlusion
#pragma oplabel "Local Vop Code"
#pragma opmininputs 1
#pragma opmaxinputs 4
#pragma label	samples	Samples
#pragma range	samples	0	10
#pragma label	parm	geo
#pragma hint	parm	geometry
#pragma label	bands	Bands
#pragma range	bands	0	10


#include <voplib.h>

#include <voptype.h>
#include <voplib.h>

#include <voptype.h>
#include <voplib.h>



#include <voptype.h>
#include <voplib.h>

#include <voptype.h>
#include <voplib.h>

#include <voptype.h>
#include <voplib.h>

#ifndef ME_SPHERICAL_HARMONICS
#define ME_SPHERICAL_HARMONICS

int factorial(int i) {
    int factorial_table[] = array(
    1,
    1,
    2,
    6,
    24,
    120,
    720,
    5040,
    40320,
    362880,
    3628800,
    39916800,
    479001600,
    6227020800,
    87178291200,
    1307674368000,
    20922789888000,
    355687428096000,
    6402373705728000,
    121645100408832000,
    2432902008176640000,
    51090942171709440000,
    1124000727777607680000,
    25852016738884976640000,
    620448401733239439360000,
    15511210043330985984000000,
    403291461126605635584000000,
    10888869450418352160768000000,
    304888344611713860501504000000,
    8841761993739701954543616000000,
    265252859812191058636308480000000,
    8222838654177922817725562880000000,
    263130836933693530167218012160000000,
    8683317618811886495518194401280000000
    );

    return factorial_table[i];
}

float P(int l; int m; float x)
{
  // evaluate an Associated Legendre Polynomial P(l,m,x) at x
  float pmm = 1.0;
  if(m>0) {
    float somx2 = sqrt((1.0-x)*(1.0+x));
    float fact = 1.0;
    int i;
    for(i=1; i<=m; i++) {
      pmm *= (-fact) * somx2;
      fact += 2.0;
    }
  }
  if(l==m) return pmm;
  float pmmp1 = x * (2.0*m+1.0) * pmm;
  if(l==m+1) return pmmp1;
  float pll = 0.0;
  int ll;
  for(ll=m+2; ll<=l; ++ll) {
    pll = ( ((float)(2.0*ll) - 1.0)*x*pmmp1 - ((float)(ll+m) - 1.0)*pmm ) / (ll - m);
    pmm = pmmp1;
    pmmp1 = pll;
  }
  return pll;
}


float K(int l; int m)
{
  // renormalisation constant for SH function
  float temp = ((2.0*l+1.0)*factorial(l-m)) / (4.0*PI*factorial(l+m));
  return sqrt(temp);
}

float SH(int l; int m; float theta; float phi)
{
  // return a point sample of a Spherical Harmonic basis function
  // l is the band, range [0..N]
  // m in the range [-l..l]
  // theta in the range [0..Pi]
  // phi in the range [0..2*Pi]

  float sqrt2 = sqrt(2.0);

  if(m==0)
    return K(l,0)*P(l,m,cos(theta));
  else if(m>0)
    return sqrt2*K(l,m)*cos(m*phi)*P(l,m,cos(theta));
  else
    return sqrt2*K(l,-m)*sin(-m*phi)*P(l,-m,cos(theta));
}

int getindex(int l; int m) {
    return (l*(l+1))+m;
}

float mtx_get(matrix matx; int index) {
/*
    float vals[9];
    vals[0] = getcomp(matx, 0, 0);
    vals[1] = getcomp(matx, 0, 1);
    vals[2] = getcomp(matx, 0, 2);
    vals[3] = getcomp(matx, 1, 0);
    vals[4] = getcomp(matx, 1, 1);
    vals[5] = getcomp(matx, 1, 2);
    vals[6] = getcomp(matx, 2, 0);
    vals[7] = getcomp(matx, 2, 1);
    vals[8] = getcomp(matx, 2, 2);
  */

    int j, k;
    // hard coded for 4x4 matrix
    j = index / 4;
    k = index % 4;

    return getcomp(matx, j, k);
}

void mtx_set(matrix mtx; int index; float val) {
    int j, k;

    // hard coded for 4x4 matrix
    j = index / 4;
    k = index % 4;

    setcomp(mtx, val, j, k);
}

#endif /* ME_SPHERICAL_HARMONICS */
sop
obj_sphere_example_sample_surrounding_occlusion(int samples = 0;
	string parm = "";
	int bands = 0)
{
    matrix	coeffs;
    string	text;
    int	scaled;
    float	rand;
    float	rand1;
    float	scaled1;
    float	trig;
    float	scaled2;
    float	complem;
    float	product;
    float	complem1;
    float	constant;
    float	max;
    float	sqrt;
    float	product1;
    float	trig1;
    float	product2;
    vector	vec1;
    vector	nvec;
    float	fval1;
    float	fval2;
    float	fval3;
    int	bool1;
    float	div;
    float	trig2;
    float	shift;
    float	added;
    float	result;
    float	scaled3;
    float	phi1;
    float	trig3;
    float	theta1;
    vector	scaled4;
    int	prim;
    vector	pos;
    float	u;
    float	v1;
    int	bool2;
    float	fval;
    float	fourpi;
    float	output1;
    float	inverse;
    float	product3;
    matrix	_coefficients;
    matrix	newadata;
    vector	nvec1;
    float	fval11;
    float	fval21;
    float	fval31;
    int	bool3;
    float	div1;
    float	trig4;
    float	shift1;
    float	added1;
    float	result1;
    float	scaled5;
    float	phi3;
    float	trig5;
    float	theta3;
    
    // Code produced by: coeffs
    coeffs = { { 0, 0, 0, 0 },{ 0, 0, 0, 0 },{ 0, 0, 0, 0 },{ 0, 0, 0, 0 } };
    
    // Code produced by: print1
    text = sprintf("op:%s", parm);
    printf("op:%s\n", parm);
    
    // Code produced by: for1
    int	_i = 0;
    int	_end = samples;
    int	_step = 1;
    matrix	_coeffs = coeffs;
    string	_text = text;
    int	_bands = bands;
    for( ; _i < _end; _i += _step )
    {
        
        // Code produced by: for1/seed
        scaled = _i * 12345;
        
        // Code produced by: for1/random1
        #ifdef __vex
            if (1)
            	rand = random(scaled);
            else
               rand = rand(scaled);
        #else
            rand = cellnoise(scaled);
        #endif
        
        // Code produced by: for1/random2
        #ifdef __vex
            if (1)
            	rand1 = random(_i);
            else
               rand1 = rand(_i);
        #else
            rand1 = cellnoise(_i);
        #endif
        
        // Code produced by: for1/warp_sample_sphere
        float	_rand = rand;
        float	_rand_2 = rand1;
        vector	vec = vector();
        {
            
            // Code produced by: for1/warp_sample_sphere/phi
            scaled1 = _rand_2 * 6.2831853071795862;
            
            // Code produced by: for1/warp_sample_sphere/trig2
            trig = vop_cos(1*scaled1 - 0);
            
            // Code produced by: for1/warp_sample_sphere/mulconst1
            scaled2 = _rand * 2;
            
            // Code produced by: for1/warp_sample_sphere/z
            complem = -scaled2;
            complem += 1;
            
            // Code produced by: for1/warp_sample_sphere/multiply1
            product = complem * complem;
            
            // Code produced by: for1/warp_sample_sphere/complement1
            complem1 = -product;
            complem1 += 1;
            
            // Code produced by: for1/warp_sample_sphere/constant1
            constant = 0;
            
            // Code produced by: for1/warp_sample_sphere/max1
            max = max( complem1 , constant );
            
            // Code produced by: for1/warp_sample_sphere/sqr
            sqrt = vop_sqrt(max);
            
            // Code produced by: for1/warp_sample_sphere/multiply3
            product1 = trig * sqrt;
            
            // Code produced by: for1/warp_sample_sphere/trig1
            trig1 = vop_sin(1*scaled1 - 0);
            
            // Code produced by: for1/warp_sample_sphere/multiply2
            product2 = sqrt * trig1;
            
            // Code produced by: for1/warp_sample_sphere/floattovec1
            vec1 = vop_floattovec(product1, complem, product2);
            
            // Code produced by: for1/warp_sample_sphere/suboutput1
            vec = vec1;
        }
        
        // Code produced by: for1/cartesian_to_spherical1
        vector	_input_vector = vec;
        float	phi = 0.0;
        float	theta = 0.0;
        {
            
            // Code produced by: for1/cartesian_to_spherical1/normalize1
            nvec = normalize(_input_vector);
            
            // Code produced by: for1/cartesian_to_spherical1/vectofloat11
            vop_vectofloat(nvec, fval1, fval2, fval3);
            
            // Code produced by: for1/cartesian_to_spherical1/z_gt_0
            bool1 = (fval3 < 0);
            
            // Code produced by: for1/cartesian_to_spherical1/divide2
            div = fval1 / fval3;
            
            // Code produced by: for1/cartesian_to_spherical1/trig4
            trig2 = vop_atan(1*div - 0);
            
            // Code produced by: for1/cartesian_to_spherical1/fit2
            shift = vop_fit(trig2, -1.5707963267948966, 1.5707963267948966, 0, 1);
            
            // Code produced by: for1/cartesian_to_spherical1/addconst1
            added = shift + 1;
            
            // Code produced by: for1/cartesian_to_spherical1/twoway2
            #ifndef __vex
              result = (0 != 0 ? (bool1 != 0 ? added : shift)
                                        : (bool1 != 0 ? shift : added));
            #else
              #if !strcmp("default", "b")
                float scale = (0 != 0 ? (bool1 != 0 ? 1 : 0)
                                               : (bool1 != 0 ? 0 : 1));
                result = (1-scale)*shift + scale*added;
              #else
                result = (0 != 0 ? (bool1 != 0 ? added : shift)
                                          : (bool1 != 0 ? shift : added));
              #endif
            #endif
            
            // Code produced by: for1/cartesian_to_spherical1/mulconst4
            scaled3 = result * 3.1415926535897931;
            
            // Code produced by: for1/cartesian_to_spherical1/phi
            phi1 = scaled3;
            
            // Code produced by: for1/cartesian_to_spherical1/trig2
            trig3 = vop_acos(1*fval2 - 0);
            
            // Code produced by: for1/cartesian_to_spherical1/theta
            theta1 = trig3;
            
            // Code produced by: for1/cartesian_to_spherical1/suboutput1
            phi = phi1;
            theta = theta1;
        }
        
        // Code produced by: for1/intersect_max_dist
        scaled4 = vec * 100000;
        
        // Code produced by: for1/intersect1
        prim = intersect(_text, { 0, 0, 0 }, scaled4, pos, u, v1, "farthest", 0);
        
        // Code produced by: for1/compare1
        bool2 = (prim != -1);
        
        // Code produced by: for1/inttofloat1
        fval = (float)bool2;
        
        // Code produced by: for1/4pi
        fourpi = 12.566370614359172;
        
        // Code produced by: for1/samples
        // No change to input _end (_end)
        
        // Code produced by: autoconvert
        output1 = _end;
        
        // Code produced by: for1/1_div_samples
        #if !strcmp("f", "f")
          inverse = 1.0 / output1;
        #else
          inverse = invert(output1);
        #endif
        
        // Code produced by: for1/multiply1
        product3 = fval * fourpi * inverse;
        
        // Code produced by: for1/sh_generate1
        int l, m;
        int c;
        for (c=0; c<16; c++) {
            mtx_set(_coefficients, c, 0.0);
        }
        
        for (l = 0; l < _bands; l++) {
            for (m = -l; m <= l; m++) {
                int index1 = getindex(l, m);
                float val = (product3 * SH(l, m, theta, phi)) + mtx_get(_coeffs, index1);
                mtx_set(_coefficients, index1, val);
            }
        }
        
        // Code produced by: for1/suboutput1
        _coeffs = _coefficients;
    }
    
    // Code produced by: addattrib1
    newadata = _coeffs;
    addattribute("c", newadata, "type", "");
    if ("" != "")
        addvariablename("c", "");
    
    // Code produced by: cartesian_to_spherical1
    vector	_input_vector1 = { 0, 0, 0 };
    float	phi2 = 0.0;
    float	theta2 = 0.0;
    {
        
        // Code produced by: cartesian_to_spherical1/normalize1
        nvec1 = normalize(_input_vector1);
        
        // Code produced by: cartesian_to_spherical1/vectofloat11
        vop_vectofloat(nvec1, fval11, fval21, fval31);
        
        // Code produced by: cartesian_to_spherical1/z_gt_0
        bool3 = (fval31 < 0);
        
        // Code produced by: cartesian_to_spherical1/divide2
        div1 = fval11 / fval31;
        
        // Code produced by: cartesian_to_spherical1/trig4
        trig4 = vop_atan(1*div1 - 0);
        
        // Code produced by: cartesian_to_spherical1/fit2
        shift1 = vop_fit(trig4, -1.5707963267948966, 1.5707963267948966, 0, 1);
        
        // Code produced by: cartesian_to_spherical1/addconst1
        added1 = shift1 + 1;
        
        // Code produced by: cartesian_to_spherical1/twoway2
        #ifndef __vex
          result1 = (0 != 0 ? (bool3 != 0 ? added1 : shift1)
                                    : (bool3 != 0 ? shift1 : added1));
        #else
          #if !strcmp("default", "b")
            float scale1 = (0 != 0 ? (bool3 != 0 ? 1 : 0)
                                           : (bool3 != 0 ? 0 : 1));
            result1 = (1-scale1)*shift1 + scale1*added1;
          #else
            result1 = (0 != 0 ? (bool3 != 0 ? added1 : shift1)
                                      : (bool3 != 0 ? shift1 : added1));
          #endif
        #endif
        
        // Code produced by: cartesian_to_spherical1/mulconst4
        scaled5 = result1 * 3.1415926535897931;
        
        // Code produced by: cartesian_to_spherical1/phi
        phi3 = scaled5;
        
        // Code produced by: cartesian_to_spherical1/trig2
        trig5 = vop_acos(1*fval21 - 0);
        
        // Code produced by: cartesian_to_spherical1/theta
        theta3 = trig5;
        
        // Code produced by: cartesian_to_spherical1/suboutput1
        phi2 = phi3;
        theta2 = theta3;
    }
}
